#!/usr/bin/env perl

=head1 NAME

jroll - Binary projects deploy (jails & ZFS based)

SYNOPSIS

jroll [ options ] project

=cut

use strict;
use warnings;
use utf8;

use FindBin;
use Getopt::Long qw( :config no_auto_abbrev bundling require_order );
use LWP::UserAgent;
use POSIX qw( strftime );
use YAML::XS qw( Load );

# command line options & config loaded
my ( %opts,$conf );

# kind of logging
sub now   { strftime '%Y-%m-%d %H:%M:%S',localtime }
sub debug { warn &now . " [debug] @_\n" if $opts{ verbose } }
sub info  { warn &now . "  [info] @_\n" }
sub fatal { die  &now . " [error] @_\n" }

# get full jail info
sub jinfo(@);

# remote command execution
sub rcmd($$);

# actions
sub cleanup();
sub deploy();
sub help();

my %cmds = (
	cleanup => \&cleanup,
	help    => \&help,
	deploy  => \&deploy,
	restart => \&restart,
	show    => \&show,
);

# just a main ;)
sub main {
	# parse common command line switches
	GetOptions(\%opts, qw(
		config|c=s
		verbose|v
	)) or goto &Help::main;

	# reasonable defaults
	$opts{ config } //= $FindBin::Bin . '/../etc/jroll.yml';

	# config loading
	{
		open my $fd, '<', $opts{ config } or
			fatal "can't found config file: $opts{ config }";
		my $yml = do { local $/ = <$fd> } or
			fatal "can't load config file: $opts{ config }";
		$conf = Load $yml or
			fatal "can't parse config file: $opts{ config }";
		debug "config loaded: $opts{ config }";
	}

	# action argument required
	my $do = shift @ARGV or
		goto &Help::main;

	# try to dispatch
	my @do = grep { /^$do/ } keys %cmds;
	goto &Help::main
		unless @do==1;
	goto &{ shift @do };
}

sub help() {
	if ( my $do = shift @ARGV ) {
		my @do = grep { /^$do/ } keys %cmds;
		goto &{ 'Help::' . $do[0] }
			if @do == 1;
	}
	goto &Help::main;
}

sub cleanup() {
	my $start = time;

	my %copts;
	GetOptions(\%copts, qw(
		dry-run|n
		keep|k=i
		group|g=s
	)) or goto &Help::main;

	# single argument required (project name)
	my $pname = shift @ARGV or die &Help::cleanup;
	goto &Help::cleanup if @ARGV;

	fatal "not implemented yet";

	info "dry-run process (read only)"
		if $copts{'dry-run'};

	# get project info
	my $proj = $conf->{ projects }{ $pname } or
		fatal "no project found: $pname";

	# all members
	my @all = sort map { @{ $proj->{ groups }{ $_ } } }
		keys %{ $proj->{ groups } };

	my $group = $copts{ group };

	my $keep = $copts{ keep } // $proj->{ keep };
	fatal "no 'keep' setting found, nothing to do"
		unless $keep && $keep =~ /^\d+$/;
	fatal "dangerous 'keep' settings '$keep' (3 minimum)"
		unless $keep > 2;

	my $mmbs = $group ? do {
		$proj->{ groups }{ $group } or
			fatal "no group '$group' defined for project";
	} : \@all;

	info "work on project: $pname (" . ( $group // 'all groups' ) . ")";

	# super info
	info "discovering super info";
	my $super = jinfo split '@',$proj->{ super };

	# all suitable snapshots
	my %every;
	for my $m ( @all ) {
		info "discovering member info ($m)";
		my $inf = jinfo split('@',$m), matched => 0;
		$every{ $_ }++ for @{ $inf->{ snapshots } };
	}

	# common snapshots
	my @common = grep { $every{ $_ } == @all } keys %every;
	info "found " . scalar( @common ) . " common snapshots";

	fatal "TODO: real cleanup";
}

sub deploy() {
	my $start = time;

	my %copts;
	GetOptions(\%copts, qw(
		dry-run|n
		group|g=s
	)) or goto &Help::main;

	# single argument required (project name)
	my $pname = shift @ARGV or die &Help::deploy;
	goto &Help::deploy if @ARGV;

	info "dry-run process (read only)"
		if $copts{'dry-run'};

	# get project info
	my $proj = $conf->{ projects }{ $pname } or
		fatal "no project found: $pname";

	my $group = $copts{ group } // $proj->{ inactive };
	if ( $group =~ m{^http://} ) {
		info "detecting inactive group via http";
		my $ua = LWP::UserAgent->new( timeout => 10 );
		my $rs = $ua->get( $group );
		fatal "can't detect inactive group: " . $rs->status_line
			unless $rs->is_success;
		$group = $rs->content;
	}
	my $mmbs = $proj->{ groups }{ $group } or
		fatal "no group '$group' defined for project";

	info "work on project: $pname ($group)";
	
	# super info
	info "discovering super info";
	my $super = jinfo split '@',$proj->{ super };

	# destinations info
	my %trts;
	for ( @$mmbs ) {
		info "discovering targets info ($_->{ id })";
		$trts{ $_->{ id } } = jinfo split '@',$_->{ id };
	}

	info "searching for latest common snapshot";
	my $base;
	for my $cnd ( @{ $super->{ snapshots } } ) {
		my $fnd = 0;
		for ( @$mmbs ) {
			$fnd++ if $trts{ $_->{ id } }->{ mss }{ $cnd };
		}
		next unless $fnd == @$mmbs;

		$base = $cnd;
		info "selected base snapshot: $base";
		last;
	}
	fatal "no one common snapshot found"
		unless $base;

	# name pattern does matter for cleanup process!
	my $last = 'jroll.' . strftime '%Y-%m-%d.%H:%M:%S',localtime;
	info "creating super snapshot: $last"; 
	rcmd $proj->{ super } => "sudo zfs snapshot $super->{ rootfs }\@$last"
		unless $copts{'dry-run'};

	my $dump = "/tmp/$FindBin::Script." . getpwuid($<) . ".$$.$pname";
	info "dumping super delta into $dump"; 
	rcmd $proj->{ super } => "sudo zfs send -I \@$base $super->{ rootfs }\@$last > $dump"
		unless $copts{'dry-run'};

	unless ( $copts{'dry-run'} ) {
		my ( $size ) = rcmd $proj->{ super } => "stat -f%z $dump";
		info "dumped $size bytes";

		if ( my @notify = @{ $proj->{ notify } // [] } ) {
			my @diff = map {[ split ' ' ]} rcmd $proj->{ super } =>
					"sudo zfs diff -FH \@$base $super->{ rootfs }\@$last";

			my ( %add,%del );
			for ( @diff ) {
				my ( $op,$tp,@ops ) = @$_;

				# only files taken in account
				next unless $tp eq 'F';

				$add{ $ops[0] }++ if $op eq '+';
				$del{ $ops[0] }++ if $op eq '-';
			}
			my $msg = <<EOM;
# Project:  $pname
# FS diff:  $super->{ rootfs } ('\@$base' => '\@$last')
#
# Oper.	Type	Path

EOM
			DIFF:
			for ( @diff ) {
				my ( $op,$tp,@ops ) = @$_;

				# skip some directoris operations
				next if $op eq 'M' && $tp eq '/';

				# well-known excludes
				my $bx = qr{ ^\Q$super->{ rootdir }\E }x;
				for my $ex (qw( .*/\.git/ /tmp/ /var/ /(?:home/[^/]+|root)/\.(?:bash_)?history )) {
					next DIFF if $ops[0] =~ qr{ $bx$ex }x;
				}

				# compact '-' and '+' into 'C'
				next if $op eq '-' && $add{ $ops[0] };
				$op = 'C' if $op eq '+' && $del{ $ops[0] };

				$msg .= "  $op\t$tp\t@ops\n";
			}

			$msg .= <<EOM;

#######################################################
# Operations:
#   -         path was removed
#   +         path was added
#   M         path was modified
#   R         path was renamed
#
# Types:
#   B         block device
#   C         character device
#   F         regular file
#   /         directory
#   @         symbolic link
#   =         socket
#######################################################
EOM

			if ( open my $mh,"|/usr/bin/mail -s 'Deploy report for $pname' " . join ',',@notify ) {
				print $mh $msg;
			} else {
				info "can't send notify mail: $!";
			}
		}
	}

	for ( @$mmbs ) {
		info "applying delta onto $_->{ id }";

		my ( $jail,$host ) = split '@',$_->{ id };
		debug "transferring dump to $host";
		rcmd $proj->{ super } => "scp -o StrictHostKeyChecking=no $dump $host:$dump"
			unless $copts{'dry-run'};

		if ( $trts{ $_->{ id } }{ running } ) {
			debug "stopping $jail\@$host";
			rcmd $host => "sudo ezjail-admin stop $jail"
				unless $copts{'dry-run'};
		} else {
			debug "already stopped $jail\@$host";
		}

		debug "rollback $jail\@$host to \@$base";
		rcmd $host => "sudo zfs rollback -r $trts{ $_->{ id } }{ rootfs }\@$base"
			unless $copts{'dry-run'};

		debug "restoring $jail\@$host to \@$last";
		rcmd $host => "sudo zfs recv $trts{ $_->{ id } }{ rootfs } < $dump"
			unless $copts{'dry-run'};

		my @fls = @{ $_->{ copy } // $proj->{ copy } // [qw( /etc/hosts /etc/resolv.conf )] };
		debug "copiyng master files: " .( join ',', @fls ) if @fls;
		for my $f ( @fls ) {
			rcmd $host => "sudo cp $f $trts{ $_->{ id } }{ rootdir }$f"
				unless $copts{'dry-run'};
		}

		unless ( $_->{ halt } ) {
			debug "starting $jail\@$host";
			rcmd $host => "sudo ezjail-admin start $jail"
				unless $copts{'dry-run'};
		} else {
			debug "skip halted $jail\@$host";
		}

		rcmd $host => "rm -f $dump"
			unless $copts{'dry-run'};
		debug "dump removed at $host";
	}

	rcmd $proj->{ super } => "rm -f $dump"
		unless $copts{'dry-run'};
	debug "super dump removed";

	info "all tasks completed successfully, elapsed ". ( time - $start ) . " seconds";
}

sub restart() {
	my $start = time;

	my %copts;
	GetOptions(\%copts, qw(
		dry-run|n
		group|g=s
	)) or goto &Help::main;

	# single argument required (project name)
	my $pname = shift @ARGV or die &Help::restart;
	goto &Help::restart if @ARGV;

	info "dry-run process (read only)"
		if $copts{'dry-run'};

	# get project info
	my $proj = $conf->{ projects }{ $pname } or
		fatal "no project found: $pname";

	my $group = $copts{ group } // $proj->{ inactive };
	if ( $group =~ m{^http://} ) {
		info "detecting inactive group via http";
		my $ua = LWP::UserAgent->new( timeout => 10 );
		my $rs = $ua->get( $group );
		fatal "can't detect inactive group: " . $rs->status_line
			unless $rs->is_success;
		$group = $rs->content;
	}
	my $mmbs = $proj->{ groups }{ $group } or
		fatal "no group '$group' defined for project";

	info "work on project: $pname ($group)";

	# destinations info
	my %trts;
	for ( @$mmbs ) {
		info "discovering targets info ($_->{ id })";
		$trts{ $_->{ id } } = jinfo split '@',$_->{ id };
	}

	for ( @$mmbs ) {
		info "restarting $_->{ id }";

		my ( $jail,$host ) = split '@',$_->{ id };

		if ( $trts{ $_->{ id } }{ running } ) {
			debug "stopping $jail\@$host";
			rcmd $host => "sudo ezjail-admin stop $jail"
				unless $copts{'dry-run'};
		} else {
			debug "already stopped $jail\@$host";
		}

		my @fls = @{ $_->{ copy } // $proj->{ copy } // [qw( /etc/hosts /etc/resolv.conf )] };
		debug "copiyng master files: " .( join ',', @fls ) if @fls;
		for my $f ( @fls ) {
			rcmd $host => "sudo cp $f $trts{ $_->{ id } }{ rootdir }$f"
				unless $copts{'dry-run'};
		}

		unless ( $_->{ halt } ) {
			debug "starting $jail\@$host";
			rcmd $host => "sudo ezjail-admin start $jail"
				unless $copts{'dry-run'};
		} else {
			debug "skip halted $jail\@$host";
		}
	}

	info "all tasks completed successfully, elapsed ". ( time - $start ) . " seconds";
}

sub show() {
	my $start = time;

	# optional arguments (projects)
	my @projs = @ARGV ? @ARGV : sort keys %{ $conf->{ projects } };

	for my $pname ( @projs ) {
		# get project info
		my $proj = $conf->{ projects }{ $pname } or
			fatal "no project found: $pname";

		my $inact = $proj->{ inactive };
		if ( $inact =~ m{^http://} ) {
			debug "detecting inactive group via http";
			my $ua = LWP::UserAgent->new( timeout => 10 );
			my $rs = $ua->get( $inact );
			fatal "can't detect inactive group: " . $rs->status_line
				unless $rs->is_success;
			$inact = $rs->content;
		}
		fatal "no group '$inact' defined for project"
			unless $proj->{ groups }{ $inact };

		info "project '$pname', $proj->{ inactive }";
		for my $grp ( sort keys %{ $proj->{ groups } } ) {
			info "group '$grp', " . ( $grp eq $inact ? 'inactive' : 'active' );
			for ( sort { $a->{id} cmp $b->{id} }  @{ $proj->{ groups }{ $grp } } ) {
				my $inf = jinfo split '@',$_->{ id };
				info "instance '$_->{ id }', " . ( $inf->{ running } ? 'running' : 'stopped' );
			}
		}
	}

	debug "all tasks completed successfully, elapsed ". ( time - $start ) . " seconds";
}

sub jinfo(@) {
	my ( $jail,$host,%kws ) = @_;

	# prepare info structure
	my $inf;

	# sanitize (like ezjail does)
	(my $name = $jail) =~ s/[^[:alnum:]]/_/g;

	# get ezjail options
	for ( rcmd $host => "cat /usr/local/etc/ezjail/$name" ) {
		my ( $k,$v ) = /^\s*export\s+jail_${ name }_(\w+)="([^"]+)"\s*$/ or
			next;
		$inf->{ $k } = $v;
	}
	debug "loaded jail settings for $jail\@$host";

	# root directory required
	fatal "can't found root directory for $jail\@$host"
		unless $inf->{ rootdir };

	# get mounted ZFS partitions
	for ( rcmd $host => 'mount -ptzfs' ) {
		my ( $fs,$mp ) = split ' ';
		next unless $mp eq $inf->{ rootdir };
		$inf->{ rootfs } = $fs; last;
	}
	debug "analyzed mount points at $host";

	# rootfs required
	fatal "can't found file system for $jail\@$host"
		unless $inf->{ rootfs };

	# get snapshots for rootfs
	for ( reverse rcmd $host => "zfs list -Hrt snapshot -oname $inf->{ rootfs }" ) {
		push @{ $inf->{ snapshots } }, ( split '@',$_ )[1];
	}

	# remove not suitable snapshots (if requested)
	$inf->{ snapshots } = [ grep { /^jail\.\d{4}-\d{2}-\d{2}\.\d{2}:\d{2}:\d{2}$/ } @{ $inf->{ snapshots } } ]
		if $kws{ matched };

	# prepare snapshots mapping
	$inf->{ mss } = { map { $_ => $_ } @{ $inf->{ snapshots } } };
	debug "got snapshots for $jail\@$host";

	# detect running states
	for ( rcmd $host => "ezjail-admin list" ) {
		my @flds = split ' ';
		next unless $flds[2] eq $inf->{ ip } && $flds[ 3 ] eq $inf->{ hostname };
		$inf->{ running } = $flds[0]=~/R/;
	}

	$inf;
}

sub rcmd($$) {
	my ( $host,$cmd ) = @_;

	# rcmd accepts host:foo as valid argument too
	$host =~ s/^.*\@//;

	chomp( my @out = qx( ssh -o StrictHostKeyChecking=no $host '$cmd' ) );
	fatal qq(can't execute remote: "@out") if $?;
	@out;
}


# go!
&main;


#
# Dedicated help namespace
#
package Help;

# generic help
sub main {
	die <<EOM . join( "\n", map { ' 'x4 . $_ } sort keys %cmds ) . "\n\n";

Usage: $FindBin::Script [options] <command> [command options] [command arguments]

Help:  $FindBin::Script help <command>

Options:
    -c, --config=FILE  config file to load
    -v, --verbose      more verbose output

Commands:
EOM
}

# help on help :)
sub help {
	die <<EOM . join( "\n", map { ' 'x4 . $_ } sort keys %cmds ) . "\n\n";

Help: brief overview about command options and arguments

Usage: help <command>

Available commands:
EOM
}

# cleanup help
sub cleanup {
	die <<EOM;

Cleanup: discard stale common jroll snapshots for group

Usage:  cleanup [options] project

Options:
    -g, --group=NAME   explicitly set group to cleanup
                       by default all groups will affected
    -k, --keep=NUM     keep NUM last common snapshots
    -n, --dry-run      show what would have been done

EOM
}

# deploy help
sub deploy {
	die <<EOM;

Deploy: apply super changes to group of instances

Usage: deploy [options] project

Options:
    -g, --group=NAME   explicitly set group to deploy
    -n, --dry-run      show what would have been done

EOM
}

# restart help
sub restart {
	die <<EOM;

Restart: stop & start group of instances

Usage: restart [options] project

Options:
    -g, --group=NAME   explicitly set group to deploy
    -n, --dry-run      show what would have been done

EOM
}

# show help
sub show {
	die <<EOM;

Show detalied information about groups and instances of projects

Usage: show [project]

EOM
}
